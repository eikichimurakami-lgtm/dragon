<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>ğŸ‰ ãƒ‰ãƒ©ã‚´ãƒ³ã‚·ãƒ¥ãƒ¼ãƒ†ã‚£ãƒ³ã‚° ğŸ”¥</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    body {
      background: #1a1a2e;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      padding: 20px;
      overflow: hidden;
      touch-action: manipulation;
    }
    
    h1 {
      color: #ff6b35;
      font-size: 2.5rem;
      margin-bottom: 20px;
      text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
    }
    
    .stats {
      display: flex;
      gap: 40px;
      margin-bottom: 15px;
      font-size: 1.3rem;
    }
    
    .score {
      color: #ffd700;
    }
    
    .level {
      color: #66ff66;
    }
    
    .hp {
      color: #ff6b6b;
    }
    
    #gameArea {
      position: relative;
      width: 1000px;
      height: 550px;
      background: linear-gradient(to bottom, #1a1a4e, #2d1b4e);
      border-radius: 10px;
      overflow: hidden;
      border: 3px solid #444;
    }
    
    .star {
      position: absolute;
      background: white;
      border-radius: 50%;
      opacity: 0.5;
    }
    
    #dragon {
      position: absolute;
      font-size: 50px;
      transition: all 0.05s;
      z-index: 10;
    }
    
    .fire {
      position: absolute;
      font-size: 28px;
      z-index: 5;
    }
    
    .enemy {
      position: absolute;
      font-size: 40px;
      z-index: 5;
    }
    
    .boss {
      position: absolute;
      font-size: 70px;
      z-index: 6;
      filter: drop-shadow(0 0 10px #ff0000);
    }
    
    .treasure {
      position: absolute;
      font-size: 35px;
      z-index: 5;
      animation: float 1s ease-in-out infinite;
    }
    
    @keyframes float {
      0%, 100% { transform: translateY(0); }
      50% { transform: translateY(-8px); }
    }
    
    #dragon.powered-up {
      filter: drop-shadow(0 0 15px #ffff00) drop-shadow(0 0 30px #ff6600);
      animation: glow 0.5s ease-in-out infinite alternate;
    }
    
    @keyframes glow {
      0% { filter: drop-shadow(0 0 15px #ffff00) drop-shadow(0 0 30px #ff6600); }
      100% { filter: drop-shadow(0 0 25px #ffff00) drop-shadow(0 0 40px #ff6600); }
    }
    
    .boss-hp-container {
      position: absolute;
      width: 60px;
      height: 8px;
      background: #333;
      border-radius: 4px;
      z-index: 7;
    }
    
    .boss-hp-bar {
      height: 100%;
      background: linear-gradient(to right, #ff0000, #ff6600);
      border-radius: 4px;
      transition: width 0.2s;
    }
    
    .overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0,0,0,0.75);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 100;
    }
    
    .overlay.hidden {
      display: none;
    }
    
    .overlay p {
      color: white;
      font-size: 1.3rem;
      margin-bottom: 15px;
    }
    
    .overlay .game-over-text {
      color: #ff4444;
      font-size: 3rem;
      font-weight: bold;
      margin-bottom: 20px;
    }
    
    .overlay .final-score {
      color: #ffd700;
      font-size: 1.8rem;
      margin-bottom: 25px;
    }
    
    .btn {
      padding: 15px 40px;
      font-size: 1.5rem;
      font-weight: bold;
      color: white;
      background: #ff6b35;
      border: none;
      border-radius: 10px;
      cursor: pointer;
      transition: background 0.3s;
    }
    
    .btn:hover {
      background: #ff8c5a;
    }
    
    .controls {
      margin-top: 15px;
      color: #888;
      font-size: 1rem;
    }
    
    /* ã‚¿ãƒƒãƒã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼ */
    .touch-controls {
      display: none;
      width: 100%;
      max-width: 1000px;
      margin-top: 20px;
      padding: 10px 15%;
      justify-content: space-between;
      align-items: center;
    }
    
    .d-pad {
      display: grid;
      grid-template-columns: 60px 60px 60px;
      grid-template-rows: 60px 60px 60px;
      gap: 5px;
    }
    
    .d-pad-btn {
      width: 60px;
      height: 60px;
      background: rgba(255, 255, 255, 0.2);
      border: 2px solid rgba(255, 255, 255, 0.4);
      border-radius: 10px;
      color: white;
      font-size: 24px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      user-select: none;
      -webkit-user-select: none;
      touch-action: manipulation;
    }
    
    .d-pad-btn:active {
      background: rgba(255, 165, 0, 0.5);
    }
    
    .d-pad-btn.empty {
      background: transparent;
      border: none;
    }
    
    .attack-btn {
      width: 100px;
      height: 100px;
      background: linear-gradient(145deg, #ff6b35, #ff4500);
      border: 3px solid #ff8c5a;
      border-radius: 50%;
      color: white;
      font-size: 36px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      user-select: none;
      -webkit-user-select: none;
      touch-action: manipulation;
      box-shadow: 0 4px 15px rgba(255, 107, 53, 0.4);
    }
    
    .attack-btn:active {
      background: linear-gradient(145deg, #ff8c5a, #ff6b35);
      transform: scale(0.95);
    }
    
    /* ã‚¹ãƒãƒ›è¡¨ç¤ºæ™‚ã«ã‚¿ãƒƒãƒã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼ã‚’è¡¨ç¤º */
    @media (max-width: 1024px) {
      .touch-controls {
        display: flex;
        padding: 10px 15%;
      }
      
      .controls {
        display: none;
      }
      
      #gameArea {
        width: 100%;
        max-width: 100vw;
        height: 45vh;
        min-height: 280px;
      }
      
      h1 {
        font-size: 1.5rem;
        margin-bottom: 10px;
      }
      
      .stats {
        font-size: 1rem;
        gap: 20px;
      }
      
      body {
        padding-bottom: 80px;
      }
      
      /* ã‚¹ãƒãƒ›ç”¨ã‚¢ã‚¤ã‚³ãƒ³ã‚µã‚¤ã‚º */
      #dragon {
        font-size: 35px;
      }
      
      .fire {
        font-size: 20px;
      }
      
      .enemy {
        font-size: 28px;
      }
      
      .boss {
        font-size: 50px;
      }
      
      .treasure {
        font-size: 28px;
      }
      
      .overlay p {
        font-size: 1.05rem;
        margin-bottom: 10px;
      }
      
      .overlay .game-over-text {
        font-size: 2.4rem;
        margin-bottom: 15px;
      }
      
      .overlay .final-score {
        font-size: 1.5rem;
        margin-bottom: 18px;
      }
      
      .btn {
        padding: 15px 38px;
        font-size: 1.3rem;
      }
    }
    
    @media (max-width: 600px) {
      .touch-controls {
        padding: 10px 10%;
        margin-top: 10px;
      }
      
      .d-pad-btn {
        width: 50px;
        height: 50px;
        font-size: 20px;
      }
      
      .d-pad {
        grid-template-columns: 50px 50px 50px;
        grid-template-rows: 50px 50px 50px;
        gap: 3px;
      }
      
      .attack-btn {
        width: 80px;
        height: 80px;
        font-size: 30px;
      }
      
      body {
        padding-bottom: 100px;
      }
      
      .overlay p {
        font-size: 0.9rem;
        margin-bottom: 8px;
        padding: 0 15px;
      }
      
      .overlay .game-over-text {
        font-size: 2rem;
        margin-bottom: 12px;
      }
      
      .overlay .final-score {
        font-size: 1.3rem;
        margin-bottom: 15px;
      }
      
      .btn {
        padding: 13px 32px;
        font-size: 1.15rem;
      }
    }
    
    @media (max-width: 400px) {
      .overlay p {
        font-size: 0.78rem;
        margin-bottom: 6px;
        padding: 0 10px;
      }
      
      .overlay .game-over-text {
        font-size: 1.7rem;
      }
      
      .overlay .final-score {
        font-size: 1.1rem;
      }
      
      .btn {
        padding: 11px 26px;
        font-size: 1.05rem;
      }
    }
  </style>
</head>
<body>
  <h1>ğŸ‰ ãƒ‰ãƒ©ã‚´ãƒ³ã‚·ãƒ¥ãƒ¼ãƒ†ã‚£ãƒ³ã‚° ğŸ”¥</h1>
  
  <div class="stats">
    <div class="score">ã‚¹ã‚³ã‚¢: <span id="scoreValue">0</span></div>
    <div class="level">ãƒ¬ãƒ™ãƒ«: <span id="levelValue">1</span></div>
    <div class="hp">HP: <span id="hpValue">â¤ï¸â¤ï¸â¤ï¸</span></div>
  </div>
  
  <div id="gameArea">
    <!-- æ˜Ÿã®èƒŒæ™¯ -->
    <div id="stars"></div>
    
    <!-- ãƒ‰ãƒ©ã‚´ãƒ³ -->
    <div id="dragon">ğŸ‰</div>
    
    <!-- ã‚¹ã‚¿ãƒ¼ãƒˆç”»é¢ -->
    <div id="startOverlay" class="overlay">
      <p>çŸ¢å°ã‚­ãƒ¼ï¼ˆã¾ãŸã¯WASDï¼‰ã§ç§»å‹•</p>
      <p>ã‚¹ãƒšãƒ¼ã‚¹ã‚­ãƒ¼ã§ç‚ã‚’æ’ƒã¤ï¼</p>
      <p style="color: #ff6666; margin-top: 10px;">ğŸ² ãƒœã‚¹ã¯3å›æ”»æ’ƒã§å€’ã›ã‚‹ï¼</p>
      <p style="color: #ffcc00;">ğŸ å®ç®±ã§3æ–¹å‘æ”»æ’ƒãƒ‘ãƒ¯ãƒ¼ã‚¢ãƒƒãƒ—ï¼</p>
      <p style="color: #66ff66;">å³å´ã§æ•µã‚’å€’ã™ã»ã©é«˜å¾—ç‚¹ï¼</p>
      <button class="btn" onclick="startGame()">ã‚²ãƒ¼ãƒ ã‚¹ã‚¿ãƒ¼ãƒˆï¼</button>
    </div>
    
    <!-- ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼ç”»é¢ -->
    <div id="gameOverOverlay" class="overlay hidden">
      <p class="game-over-text">ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼</p>
      <p class="final-score">ã‚¹ã‚³ã‚¢: <span id="finalScore">0</span></p>
      <button class="btn" onclick="restartGame()">ã‚‚ã†ä¸€å›ï¼</button>
    </div>
  </div>
  
  <div class="controls">
    â¬†ï¸â¬‡ï¸â¬…ï¸â¡ï¸ ã¾ãŸã¯ WASD ã§ç§»å‹• ï½œ ã‚¹ãƒšãƒ¼ã‚¹ã‚­ãƒ¼ã§æ”»æ’ƒ ï½œ å³å´ã§å€’ã™ã»ã©é«˜å¾—ç‚¹ï¼
  </div>
  
  <!-- ã‚¿ãƒƒãƒã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼ï¼ˆã‚¹ãƒãƒ›ç”¨ï¼‰ -->
  <div class="touch-controls">
    <div class="d-pad">
      <div class="d-pad-btn empty"></div>
      <div class="d-pad-btn" id="btn-up">â¬†ï¸</div>
      <div class="d-pad-btn empty"></div>
      <div class="d-pad-btn" id="btn-left">â¬…ï¸</div>
      <div class="d-pad-btn empty"></div>
      <div class="d-pad-btn" id="btn-right">â¡ï¸</div>
      <div class="d-pad-btn empty"></div>
      <div class="d-pad-btn" id="btn-down">â¬‡ï¸</div>
      <div class="d-pad-btn empty"></div>
    </div>
    <div class="attack-btn" id="btn-attack">ğŸ”¥</div>
  </div>

  <script>
    // ã‚²ãƒ¼ãƒ çŠ¶æ…‹
    let dragon = { x: 100, y: 250 };
    let fires = [];
    let enemies = [];
    let bosses = [];
    let score = 0;
    let hp = 3;
    let gameOver = false;
    let gameStarted = false;
    let gameLoopId = null;
    let gameStartTime = 0;
    let currentLevel = 1;
    let lastBossTime = 0;
    let treasures = [];
    let lastTreasureLevel = 0;
    let isPoweredUp = false;
    let powerUpEndTime = 0;
    
    // ã‚²ãƒ¼ãƒ ã‚¨ãƒªã‚¢ã®ã‚µã‚¤ã‚ºã‚’å–å¾—ã™ã‚‹é–¢æ•°
    function getGameAreaSize() {
      const gameArea = document.getElementById('gameArea');
      return {
        width: gameArea.offsetWidth,
        height: gameArea.offsetHeight
      };
    }
    
    // ã‚ªãƒ¼ãƒ‡ã‚£ã‚ªã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆ
    let audioCtx = null;
    let bgmOscillator = null;
    let bgmGain = null;
    
    // ã‚ªãƒ¼ãƒ‡ã‚£ã‚ªåˆæœŸåŒ–
    function initAudio() {
      if (!audioCtx) {
        audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      }
    }
    
    // BGMé–‹å§‹
    function startBGM() {
      if (!audioCtx) return;
      
      stopBGM();
      
      bgmGain = audioCtx.createGain();
      bgmGain.gain.value = 0.1;
      bgmGain.connect(audioCtx.destination);
      
      // ãƒ¡ãƒ­ãƒ‡ã‚£ãƒ‘ã‚¿ãƒ¼ãƒ³ï¼ˆ4å°ç¯€åˆ†ï¼‰
      const melodyPatterns = [
        [261.63, 329.63, 392.00, 329.63],  // C E G E
        [293.66, 349.23, 440.00, 349.23],  // D F A F
        [329.63, 392.00, 493.88, 392.00],  // E G B G
        [261.63, 392.00, 523.25, 392.00],  // C G C5 G
      ];
      
      // ãƒ™ãƒ¼ã‚¹ãƒ‘ã‚¿ãƒ¼ãƒ³
      const bassPatterns = [
        [130.81, 130.81, 98.00, 98.00],    // C2
        [146.83, 146.83, 110.00, 110.00],  // D2
        [164.81, 164.81, 123.47, 123.47],  // E2
        [130.81, 130.81, 130.81, 196.00],  // C2 G2
      ];
      
      let patternIndex = 0;
      let noteIndex = 0;
      let beatCount = 0;
      
      function playBeat() {
        if (gameOver || !gameStarted) return;
        
        const currentMelody = melodyPatterns[patternIndex];
        const currentBass = bassPatterns[patternIndex];
        
        // ãƒ¡ãƒ­ãƒ‡ã‚£éŸ³
        const melodyOsc = audioCtx.createOscillator();
        const melodyGain = audioCtx.createGain();
        melodyOsc.type = 'triangle';
        melodyOsc.frequency.value = currentMelody[noteIndex];
        melodyGain.gain.setValueAtTime(0.08, audioCtx.currentTime);
        melodyGain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.18);
        melodyOsc.connect(melodyGain);
        melodyGain.connect(audioCtx.destination);
        melodyOsc.start();
        melodyOsc.stop(audioCtx.currentTime + 0.2);
        
        // ãƒ™ãƒ¼ã‚¹éŸ³ï¼ˆ2æ‹ã«1å›ï¼‰
        if (noteIndex % 2 === 0) {
          const bassOsc = audioCtx.createOscillator();
          const bassGain = audioCtx.createGain();
          bassOsc.type = 'sine';
          bassOsc.frequency.value = currentBass[noteIndex];
          bassGain.gain.setValueAtTime(0.12, audioCtx.currentTime);
          bassGain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.35);
          bassOsc.connect(bassGain);
          bassGain.connect(audioCtx.destination);
          bassOsc.start();
          bassOsc.stop(audioCtx.currentTime + 0.4);
        }
        
        // ãƒ‰ãƒ©ãƒ çš„ãªãƒ‘ãƒ¼ã‚«ãƒƒã‚·ãƒ§ãƒ³ï¼ˆ4æ‹ã«1å›ï¼‰
        if (beatCount % 4 === 0) {
          const kickOsc = audioCtx.createOscillator();
          const kickGain = audioCtx.createGain();
          kickOsc.type = 'sine';
          kickOsc.frequency.setValueAtTime(150, audioCtx.currentTime);
          kickOsc.frequency.exponentialRampToValueAtTime(50, audioCtx.currentTime + 0.1);
          kickGain.gain.setValueAtTime(0.15, audioCtx.currentTime);
          kickGain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.1);
          kickOsc.connect(kickGain);
          kickGain.connect(audioCtx.destination);
          kickOsc.start();
          kickOsc.stop(audioCtx.currentTime + 0.1);
        }
        
        // ãƒã‚¤ãƒãƒƒãƒˆçš„ãªéŸ³ï¼ˆæ¯æ‹ï¼‰
        const hihatOsc = audioCtx.createOscillator();
        const hihatGain = audioCtx.createGain();
        hihatOsc.type = 'square';
        hihatOsc.frequency.value = 800 + Math.random() * 200;
        hihatGain.gain.setValueAtTime(0.02, audioCtx.currentTime);
        hihatGain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.05);
        hihatOsc.connect(hihatGain);
        hihatGain.connect(audioCtx.destination);
        hihatOsc.start();
        hihatOsc.stop(audioCtx.currentTime + 0.05);
        
        noteIndex++;
        beatCount++;
        
        // 1å°ç¯€ï¼ˆ4æ‹ï¼‰çµ‚ã‚ã£ãŸã‚‰æ¬¡ã®ãƒ‘ã‚¿ãƒ¼ãƒ³
        if (noteIndex >= 4) {
          noteIndex = 0;
          patternIndex = (patternIndex + 1) % melodyPatterns.length;
        }
        
        if (!gameOver && gameStarted) {
          setTimeout(playBeat, 200);
        }
      }
      
      playBeat();
    }
    
    function stopBGM() {
      if (bgmOscillator) {
        try { bgmOscillator.stop(); } catch(e) {}
        bgmOscillator = null;
      }
    }
    
    // åŠ¹æœéŸ³ï¼šç‚ã‚’æ’ƒã¤
    function playShootSound() {
      if (!audioCtx) return;
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      osc.type = 'sawtooth';
      osc.frequency.setValueAtTime(800, audioCtx.currentTime);
      osc.frequency.exponentialRampToValueAtTime(200, audioCtx.currentTime + 0.1);
      gain.gain.setValueAtTime(0.2, audioCtx.currentTime);
      gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.1);
      osc.connect(gain);
      gain.connect(audioCtx.destination);
      osc.start();
      osc.stop(audioCtx.currentTime + 0.1);
    }
    
    // åŠ¹æœéŸ³ï¼šæ•µã‚’å€’ã—ãŸ
    function playHitSound() {
      if (!audioCtx) return;
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      osc.type = 'square';
      osc.frequency.setValueAtTime(400, audioCtx.currentTime);
      osc.frequency.exponentialRampToValueAtTime(800, audioCtx.currentTime + 0.1);
      gain.gain.setValueAtTime(0.15, audioCtx.currentTime);
      gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.15);
      osc.connect(gain);
      gain.connect(audioCtx.destination);
      osc.start();
      osc.stop(audioCtx.currentTime + 0.15);
    }
    
    // åŠ¹æœéŸ³ï¼šãƒœã‚¹ã«ãƒ€ãƒ¡ãƒ¼ã‚¸
    function playBossHitSound() {
      if (!audioCtx) return;
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      osc.type = 'sawtooth';
      osc.frequency.setValueAtTime(200, audioCtx.currentTime);
      osc.frequency.exponentialRampToValueAtTime(100, audioCtx.currentTime + 0.2);
      gain.gain.setValueAtTime(0.25, audioCtx.currentTime);
      gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.2);
      osc.connect(gain);
      gain.connect(audioCtx.destination);
      osc.start();
      osc.stop(audioCtx.currentTime + 0.2);
    }
    
    // åŠ¹æœéŸ³ï¼šãƒœã‚¹æ’ƒç ´
    function playBossDefeatedSound() {
      if (!audioCtx) return;
      [0, 0.1, 0.2, 0.3].forEach((delay, i) => {
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.type = 'square';
        osc.frequency.value = 300 + i * 100;
        gain.gain.setValueAtTime(0, audioCtx.currentTime + delay);
        gain.gain.linearRampToValueAtTime(0.2, audioCtx.currentTime + delay + 0.05);
        gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + delay + 0.15);
        osc.connect(gain);
        gain.connect(audioCtx.destination);
        osc.start(audioCtx.currentTime + delay);
        osc.stop(audioCtx.currentTime + delay + 0.15);
      });
    }
    
    // åŠ¹æœéŸ³ï¼šãƒ€ãƒ¡ãƒ¼ã‚¸
    function playDamageSound() {
      if (!audioCtx) return;
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      osc.type = 'sawtooth';
      osc.frequency.setValueAtTime(150, audioCtx.currentTime);
      osc.frequency.exponentialRampToValueAtTime(50, audioCtx.currentTime + 0.3);
      gain.gain.setValueAtTime(0.3, audioCtx.currentTime);
      gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.3);
      osc.connect(gain);
      gain.connect(audioCtx.destination);
      osc.start();
      osc.stop(audioCtx.currentTime + 0.3);
    }
    
    // åŠ¹æœéŸ³ï¼šã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼
    function playGameOverSound() {
      if (!audioCtx) return;
      [0, 0.2, 0.4].forEach((delay, i) => {
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.type = 'sawtooth';
        osc.frequency.value = 200 - i * 50;
        gain.gain.setValueAtTime(0, audioCtx.currentTime + delay);
        gain.gain.linearRampToValueAtTime(0.2, audioCtx.currentTime + delay + 0.05);
        gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + delay + 0.2);
        osc.connect(gain);
        gain.connect(audioCtx.destination);
        osc.start(audioCtx.currentTime + delay);
        osc.stop(audioCtx.currentTime + delay + 0.25);
      });
    }
    
    // DOMè¦ç´ 
    const gameArea = document.getElementById('gameArea');
    const dragonEl = document.getElementById('dragon');
    const startOverlay = document.getElementById('startOverlay');
    const gameOverOverlay = document.getElementById('gameOverOverlay');
    const scoreValue = document.getElementById('scoreValue');
    const levelValue = document.getElementById('levelValue');
    const hpValue = document.getElementById('hpValue');
    const finalScore = document.getElementById('finalScore');
    
    // æ˜Ÿã®èƒŒæ™¯ã‚’ç”Ÿæˆ
    function createStars() {
      const starsContainer = document.getElementById('stars');
      const size = getGameAreaSize();
      for (let i = 0; i < 50; i++) {
        const star = document.createElement('div');
        star.className = 'star';
        star.style.width = '2px';
        star.style.height = '2px';
        star.style.left = Math.random() * size.width + 'px';
        star.style.top = Math.random() * size.height + 'px';
        starsContainer.appendChild(star);
      }
    }
    
    function updateDragonPosition() {
      dragonEl.style.left = dragon.x + 'px';
      dragonEl.style.top = dragon.y + 'px';
    }
    
    function updateHP() {
      hpValue.textContent = 'â¤ï¸'.repeat(hp) + 'ğŸ–¤'.repeat(3 - hp);
    }
    
    function updateScore() {
      scoreValue.textContent = score;
    }
    
    // ã‚­ãƒ¼å…¥åŠ›å‡¦ç†
    function handleKeyDown(e) {
      if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', ' ', 'Spacebar'].includes(e.key)) {
        e.preventDefault();
      }
      
      if (gameOver || !gameStarted) return;
      
      const speed = 40;
      const size = getGameAreaSize();
      
      if (e.key === 'ArrowUp' || e.key === 'w' || e.key === 'W') {
        dragon.y = Math.max(20, dragon.y - speed);
      }
      if (e.key === 'ArrowDown' || e.key === 's' || e.key === 'S') {
        dragon.y = Math.min(size.height - 60, dragon.y + speed);
      }
      if (e.key === 'ArrowLeft' || e.key === 'a' || e.key === 'A') {
        dragon.x = Math.max(20, dragon.x - speed);
      }
      if (e.key === 'ArrowRight' || e.key === 'd' || e.key === 'D') {
        dragon.x = Math.min(size.width * 0.4, dragon.x + speed);
      }
      
      updateDragonPosition();
      
      if (e.key === ' ' || e.key === 'Spacebar') {
        shootFire();
      }
    }
    
    // ç‚ã‚’æ’ƒã¤
    function shootFire() {
      // ãƒ‘ãƒ¯ãƒ¼ã‚¢ãƒƒãƒ—ä¸­ã¯3æ–¹å‘ã€é€šå¸¸ã¯1æ–¹å‘
      const directions = isPoweredUp 
        ? [0, -4, 4]  // ç›´é€²ã€æ–œã‚ä¸Šã€æ–œã‚ä¸‹
        : [0];        // ç›´é€²ã®ã¿
      
      directions.forEach(speedY => {
        const fire = {
          x: dragon.x + 50,
          y: dragon.y + 15,
          speedY: speedY,
          id: Date.now() + speedY,
          element: null
        };
        
        const fireEl = document.createElement('div');
        fireEl.className = 'fire';
        fireEl.textContent = 'ğŸ”¥';
        fireEl.style.left = fire.x + 'px';
        fireEl.style.top = fire.y + 'px';
        gameArea.appendChild(fireEl);
        
        fire.element = fireEl;
        fires.push(fire);
      });
      
      playShootSound();
    }
    
    // å®ç®±ã‚’ç”Ÿæˆ
    function spawnTreasure() {
      const size = getGameAreaSize();
      const treasure = {
        x: size.width + 50,
        y: Math.random() * (size.height - 80) + 40,
        speed: 1.2,
        id: Date.now(),
        element: null
      };
      
      const treasureEl = document.createElement('div');
      treasureEl.className = 'treasure';
      treasureEl.textContent = 'ğŸ';
      treasureEl.style.left = treasure.x + 'px';
      treasureEl.style.top = treasure.y + 'px';
      gameArea.appendChild(treasureEl);
      
      treasure.element = treasureEl;
      treasures.push(treasure);
    }
    
    // ãƒ‘ãƒ¯ãƒ¼ã‚¢ãƒƒãƒ—é–‹å§‹
    function activatePowerUp() {
      isPoweredUp = true;
      powerUpEndTime = Date.now() + 15000; // 15ç§’é–“
      dragonEl.classList.add('powered-up');
      playPowerUpSound();
    }
    
    // ãƒ‘ãƒ¯ãƒ¼ã‚¢ãƒƒãƒ—åŠ¹æœéŸ³
    function playPowerUpSound() {
      if (!audioCtx) return;
      [0, 0.1, 0.2].forEach((delay, i) => {
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.type = 'sine';
        osc.frequency.value = 400 + i * 200;
        gain.gain.setValueAtTime(0, audioCtx.currentTime + delay);
        gain.gain.linearRampToValueAtTime(0.2, audioCtx.currentTime + delay + 0.05);
        gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + delay + 0.2);
        osc.connect(gain);
        gain.connect(audioCtx.destination);
        osc.start(audioCtx.currentTime + delay);
        osc.stop(audioCtx.currentTime + delay + 0.25);
      });
    }
    
    // æ•µã‚’ç”Ÿæˆ
    function spawnEnemy() {
      const enemyTypes = ['ğŸ‘»', 'ğŸ‘¾', 'ğŸ¦‡'];
      const elapsedSeconds = (Date.now() - gameStartTime) / 1000;
      currentLevel = Math.floor(elapsedSeconds / 10) + 1;
      
      // ãƒ¬ãƒ™ãƒ«3ã”ã¨ã«æ®µéšçš„ã«ã‚¹ãƒ”ãƒ¼ãƒ‰ã‚¢ãƒƒãƒ— (ãƒ¬ãƒ™ãƒ«1-3, 4-6, 7-9...)
      const speedTier = Math.floor((currentLevel - 1) / 3);
      const baseSpeed = 0.8 + speedTier * 0.5;
      const speedVariation = Math.random() * 0.8;
      
      const isDiagonal = Math.random() < 0.5;
      const speedY = isDiagonal ? (Math.random() < 0.5 ? 1.5 : -1.5) + (Math.random() - 0.5) : 0;
      
      const size = getGameAreaSize();
      const enemy = {
        x: size.width + 50,
        y: Math.random() * (size.height - 80) + 30,
        id: Date.now(),
        speed: baseSpeed + speedVariation,
        speedY: speedY,
        isDiagonal: isDiagonal,
        type: enemyTypes[Math.floor(Math.random() * enemyTypes.length)],
        element: null
      };
      
      const enemyEl = document.createElement('div');
      enemyEl.className = 'enemy';
      enemyEl.textContent = enemy.type;
      enemyEl.style.left = enemy.x + 'px';
      enemyEl.style.top = enemy.y + 'px';
      gameArea.appendChild(enemyEl);
      
      enemy.element = enemyEl;
      enemies.push(enemy);
    }
    
    // ãƒœã‚¹ã‚’ç”Ÿæˆ
    function spawnBoss() {
      const size = getGameAreaSize();
      // ãƒ¬ãƒ™ãƒ«3ã”ã¨ã«æ®µéšçš„ã«ã‚¹ãƒ”ãƒ¼ãƒ‰ã‚¢ãƒƒãƒ—
      const speedTier = Math.floor((currentLevel - 1) / 3);
      const bossSpeed = 0.8 + speedTier * 0.3;
      
      const boss = {
        x: size.width + 50,
        y: size.height / 2 - 50 + Math.random() * 100,
        id: Date.now(),
        speed: bossSpeed,
        speedY: 1.5,
        hp: 3,
        maxHp: 3,
        element: null,
        hpBar: null
      };
      
      const bossEl = document.createElement('div');
      bossEl.className = 'boss';
      bossEl.textContent = 'ğŸ²';
      bossEl.style.left = boss.x + 'px';
      bossEl.style.top = boss.y + 'px';
      gameArea.appendChild(bossEl);
      
      const hpBarContainer = document.createElement('div');
      hpBarContainer.className = 'boss-hp-container';
      hpBarContainer.style.left = boss.x + 'px';
      hpBarContainer.style.top = (boss.y - 15) + 'px';
      
      const hpBar = document.createElement('div');
      hpBar.className = 'boss-hp-bar';
      hpBar.style.width = '100%';
      hpBarContainer.appendChild(hpBar);
      gameArea.appendChild(hpBarContainer);
      
      boss.element = bossEl;
      boss.hpBar = hpBarContainer;
      bosses.push(boss);
    }
    
    // å½“ãŸã‚Šåˆ¤å®š
    function checkCollision(obj1, obj2, size1, size2) {
      return obj1.x < obj2.x + size2 &&
             obj1.x + size1 > obj2.x &&
             obj1.y < obj2.y + size2 &&
             obj1.y + size1 > obj2.y;
    }
    
    // ã‚²ãƒ¼ãƒ ãƒ«ãƒ¼ãƒ—
    function gameLoop() {
      if (gameOver || !gameStarted) return;
      
      // ãƒ¬ãƒ™ãƒ«è¡¨ç¤ºã‚’æ›´æ–°
      const elapsedSeconds = (Date.now() - gameStartTime) / 1000;
      const newLevel = Math.floor(elapsedSeconds / 10) + 1;
      if (newLevel !== currentLevel) {
        currentLevel = newLevel;
        levelValue.textContent = currentLevel;
      }
      
      // ã‚²ãƒ¼ãƒ ã‚¨ãƒªã‚¢ã‚µã‚¤ã‚ºã‚’å–å¾—
      const size = getGameAreaSize();
      
      // ãƒ‘ãƒ¯ãƒ¼ã‚¢ãƒƒãƒ—ã®çµ‚äº†ãƒã‚§ãƒƒã‚¯
      if (isPoweredUp && Date.now() > powerUpEndTime) {
        isPoweredUp = false;
        dragonEl.classList.remove('powered-up');
      }
      
      // ç‚ã‚’ç§»å‹•
      fires = fires.filter(fire => {
        fire.x += 15;
        if (fire.speedY) {
          fire.y += fire.speedY;
        }
        // ç”»é¢å¤–ã«å‡ºãŸã‚‰å‰Šé™¤
        if (fire.x > size.width + 50 || fire.y < -30 || fire.y > size.height + 30) {
          fire.element.remove();
          return false;
        }
        fire.element.style.left = fire.x + 'px';
        fire.element.style.top = fire.y + 'px';
        return true;
      });
      
      // å®ç®±ã‚’ç§»å‹•
      treasures = treasures.filter(treasure => {
        treasure.x -= treasure.speed;
        if (treasure.x < -50) {
          treasure.element.remove();
          return false;
        }
        treasure.element.style.left = treasure.x + 'px';
        return true;
      });
      
      // ãƒ¬ãƒ™ãƒ«3ã”ã¨ã«å®ç®±ã‚’å‡ºç¾ã•ã›ã‚‹ï¼ˆãƒ¬ãƒ™ãƒ«3, 6, 9...ï¼‰
      const treasureLevel = Math.floor(currentLevel / 3);
      if (treasureLevel > 0 && treasureLevel > lastTreasureLevel && currentLevel % 3 === 0) {
        spawnTreasure();
        lastTreasureLevel = treasureLevel;
      }
      
      // ãƒ‰ãƒ©ã‚´ãƒ³ã¨å®ç®±ã®å½“ãŸã‚Šåˆ¤å®š
      treasures = treasures.filter(treasure => {
        if (checkCollision(dragon, treasure, 50, 35)) {
          treasure.element.remove();
          activatePowerUp();
          return false;
        }
        return true;
      });
      
      // æ•µã‚’ç§»å‹•
      enemies = enemies.filter(enemy => {
        enemy.x -= enemy.speed;
        
        if (enemy.isDiagonal) {
          enemy.y += enemy.speedY;
          
          if (enemy.y <= 10) {
            enemy.y = 10;
            enemy.speedY = Math.abs(enemy.speedY);
          }
          if (enemy.y >= size.height - 50) {
            enemy.y = size.height - 50;
            enemy.speedY = -Math.abs(enemy.speedY);
          }
          
          enemy.element.style.top = enemy.y + 'px';
        }
        
        if (enemy.x < -50) {
          enemy.element.remove();
          return false;
        }
        enemy.element.style.left = enemy.x + 'px';
        return true;
      });
      
      // æ•µã‚’è¿½åŠ ï¼ˆãƒ©ãƒ³ãƒ€ãƒ ï¼‰- ãƒ¬ãƒ™ãƒ«ã«å¿œã˜ã¦å‡ºç¾é »åº¦ã‚’ä¸Šã’ã‚‹
      // ãƒ¬ãƒ™ãƒ«1: 0.5%, ãƒ¬ãƒ™ãƒ«4: 1.5%, æœ€å¤§3%
      const spawnChance = Math.min(0.03, 0.005 + (currentLevel - 1) * 0.0033);
      if (Math.random() < spawnChance) {
        spawnEnemy();
      }
      
      // ãƒœã‚¹ã‚’20ç§’ã”ã¨ã«è¿½åŠ 
      const elapsedTime = Date.now() - gameStartTime;
      if (elapsedTime - lastBossTime >= 20000) {
        spawnBoss();
        lastBossTime = elapsedTime;
      }
      
      // ãƒœã‚¹ã‚’ç§»å‹•
      bosses = bosses.filter(boss => {
        // å·¦ã«ç§»å‹•ã—ç¶šã‘ã‚‹
        boss.x -= boss.speed;
        
        // ä¸Šä¸‹ã«å‹•ã
        boss.y += boss.speedY;
        
        if (boss.y <= 30) {
          boss.y = 30;
          boss.speedY = Math.abs(boss.speedY);
        }
        if (boss.y >= size.height - 90) {
          boss.y = size.height - 90;
          boss.speedY = -Math.abs(boss.speedY);
        }
        
        // ç”»é¢å¤–ã«å‡ºãŸã‚‰å‰Šé™¤
        if (boss.x < -80) {
          boss.element.remove();
          boss.hpBar.remove();
          return false;
        }
        
        boss.element.style.left = boss.x + 'px';
        boss.element.style.top = boss.y + 'px';
        boss.hpBar.style.left = boss.x + 'px';
        boss.hpBar.style.top = (boss.y - 15) + 'px';
        return true;
      });
      
      // ç‚ã¨æ•µã®å½“ãŸã‚Šåˆ¤å®š
      fires.forEach((fire, fIndex) => {
        enemies.forEach((enemy, eIndex) => {
          if (checkCollision(fire, enemy, 30, 40)) {
            const positionBonus = Math.floor(dragon.x / (size.width * 0.4) * 20);
            const points = 10 + positionBonus;
            score += points;
            updateScore();
            fire.element.remove();
            enemy.element.remove();
            fires.splice(fIndex, 1);
            enemies.splice(eIndex, 1);
            playHitSound();
          }
        });
        
        // ç‚ã¨ãƒœã‚¹ã®å½“ãŸã‚Šåˆ¤å®š
        bosses.forEach((boss, bIndex) => {
          if (checkCollision(fire, boss, 30, 70)) {
            boss.hp--;
            fire.element.remove();
            fires.splice(fIndex, 1);
            
            const hpPercent = (boss.hp / boss.maxHp) * 100;
            boss.hpBar.firstChild.style.width = hpPercent + '%';
            
            if (boss.hp <= 0) {
              const positionBonus = Math.floor(dragon.x / (size.width * 0.4) * 50);
              const points = 100 + positionBonus;
              score += points;
              updateScore();
              boss.element.remove();
              boss.hpBar.remove();
              bosses.splice(bIndex, 1);
              playBossDefeatedSound();
            } else {
              playBossHitSound();
            }
          }
        });
      });
      
      // ãƒ‰ãƒ©ã‚´ãƒ³ã¨æ•µã®å½“ãŸã‚Šåˆ¤å®š
      enemies.forEach((enemy, eIndex) => {
        if (checkCollision(dragon, enemy, 50, 40)) {
          hp--;
          updateHP();
          enemy.element.remove();
          enemies.splice(eIndex, 1);
          playDamageSound();
          
          if (hp <= 0) {
            endGame();
          }
        }
      });
      
      // ãƒ‰ãƒ©ã‚´ãƒ³ã¨ãƒœã‚¹ã®å½“ãŸã‚Šåˆ¤å®š
      bosses.forEach((boss, bIndex) => {
        if (checkCollision(dragon, boss, 50, 70)) {
          hp--;
          updateHP();
          playDamageSound();
          
          dragon.x = Math.max(20, dragon.x - 50);
          updateDragonPosition();
          
          if (hp <= 0) {
            endGame();
          }
        }
      });
      
      gameLoopId = requestAnimationFrame(gameLoop);
    }
    
    // ã‚²ãƒ¼ãƒ é–‹å§‹
    function startGame() {
      initAudio();
      gameStarted = true;
      gameStartTime = Date.now();
      lastBossTime = -10000;  // æœ€åˆã®ãƒœã‚¹ã‚’10ç§’å¾Œã«å‡ºã™ãŸã‚
      lastTreasureLevel = 0;
      isPoweredUp = false;
      powerUpEndTime = 0;
      dragonEl.classList.remove('powered-up');
      startOverlay.classList.add('hidden');
      startBGM();
      gameLoop();
    }
    
    // ã‚²ãƒ¼ãƒ çµ‚äº†
    function endGame() {
      gameOver = true;
      isPoweredUp = false;
      dragonEl.classList.remove('powered-up');
      cancelAnimationFrame(gameLoopId);
      stopBGM();
      playGameOverSound();
      finalScore.textContent = score;
      gameOverOverlay.classList.remove('hidden');
    }
    
    // ã‚²ãƒ¼ãƒ ãƒªã‚¹ã‚¿ãƒ¼ãƒˆ
    function restartGame() {
      fires.forEach(fire => fire.element.remove());
      enemies.forEach(enemy => enemy.element.remove());
      bosses.forEach(boss => {
        boss.element.remove();
        boss.hpBar.remove();
      });
      treasures.forEach(treasure => treasure.element.remove());
      
      const size = getGameAreaSize();
      dragon = { x: 80, y: size.height / 2 - 25 };
      fires = [];
      enemies = [];
      bosses = [];
      treasures = [];
      score = 0;
      hp = 3;
      gameOver = false;
      gameStarted = true;
      gameStartTime = Date.now();
      currentLevel = 1;
      lastBossTime = -10000;  // æœ€åˆã®ãƒœã‚¹ã‚’10ç§’å¾Œã«å‡ºã™ãŸã‚
      lastTreasureLevel = 0;
      isPoweredUp = false;
      powerUpEndTime = 0;
      dragonEl.classList.remove('powered-up');
      
      updateDragonPosition();
      updateScore();
      updateHP();
      levelValue.textContent = 1;
      
      gameOverOverlay.classList.add('hidden');
      
      startBGM();
      gameLoop();
    }
    
    // åˆæœŸåŒ–
    function initGame() {
      const size = getGameAreaSize();
      dragon = { x: 80, y: size.height / 2 - 25 };
      createStars();
      updateDragonPosition();
    }
    
    initGame();
    window.addEventListener('keydown', handleKeyDown);
    
    // ã‚¿ãƒƒãƒã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼ã®è¨­å®š
    let moveInterval = null;
    const speed = 40;
    
    function startMove(direction) {
      if (gameOver || !gameStarted) return;
      
      moveDragon(direction);
      
      moveInterval = setInterval(() => {
        if (gameOver || !gameStarted) {
          stopMove();
          return;
        }
        moveDragon(direction);
      }, 100);
    }
    
    function moveDragon(direction) {
      const size = getGameAreaSize();
      if (direction === 'up') dragon.y = Math.max(20, dragon.y - speed);
      if (direction === 'down') dragon.y = Math.min(size.height - 60, dragon.y + speed);
      if (direction === 'left') dragon.x = Math.max(20, dragon.x - speed);
      if (direction === 'right') dragon.x = Math.min(size.width * 0.4, dragon.x + speed);
      updateDragonPosition();
    }
    
    function stopMove() {
      if (moveInterval) {
        clearInterval(moveInterval);
        moveInterval = null;
      }
    }
    
    const btnUp = document.getElementById('btn-up');
    const btnDown = document.getElementById('btn-down');
    const btnLeft = document.getElementById('btn-left');
    const btnRight = document.getElementById('btn-right');
    const btnAttack = document.getElementById('btn-attack');
    
    btnUp.addEventListener('touchstart', (e) => { e.preventDefault(); startMove('up'); });
    btnUp.addEventListener('touchend', stopMove);
    btnUp.addEventListener('touchcancel', stopMove);
    
    btnDown.addEventListener('touchstart', (e) => { e.preventDefault(); startMove('down'); });
    btnDown.addEventListener('touchend', stopMove);
    btnDown.addEventListener('touchcancel', stopMove);
    
    btnLeft.addEventListener('touchstart', (e) => { e.preventDefault(); startMove('left'); });
    btnLeft.addEventListener('touchend', stopMove);
    btnLeft.addEventListener('touchcancel', stopMove);
    
    btnRight.addEventListener('touchstart', (e) => { e.preventDefault(); startMove('right'); });
    btnRight.addEventListener('touchend', stopMove);
    btnRight.addEventListener('touchcancel', stopMove);
    
    btnAttack.addEventListener('touchstart', (e) => {
      e.preventDefault();
      if (gameOver || !gameStarted) return;
      shootFire();
    });
    
    btnUp.addEventListener('mousedown', () => startMove('up'));
    btnUp.addEventListener('mouseup', stopMove);
    btnUp.addEventListener('mouseleave', stopMove);
    
    btnDown.addEventListener('mousedown', () => startMove('down'));
    btnDown.addEventListener('mouseup', stopMove);
    btnDown.addEventListener('mouseleave', stopMove);
    
    btnLeft.addEventListener('mousedown', () => startMove('left'));
    btnLeft.addEventListener('mouseup', stopMove);
    btnLeft.addEventListener('mouseleave', stopMove);
    
    btnRight.addEventListener('mousedown', () => startMove('right'));
    btnRight.addEventListener('mouseup', stopMove);
    btnRight.addEventListener('mouseleave', stopMove);
    
    btnAttack.addEventListener('mousedown', () => {
      if (gameOver || !gameStarted) return;
      shootFire();
    });
  </script>
</body>
</html>
